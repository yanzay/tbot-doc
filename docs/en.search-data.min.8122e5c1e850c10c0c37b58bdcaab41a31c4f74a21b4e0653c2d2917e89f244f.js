'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/tbot-doc/basics/','title':"Basics",'content':"Telegram Bot Basics Register a Bot First of all, you need to create a bot in Telegram. There is a special bot for this purpose - @BotFather. Open chat with BotFather and press “Start” to start chat with it. It will show you help message to guide through the steps:\n Click /newbot link in the help message, or send /newbot message to chat. Then BotFather will ask you for the name of your bot. You can choose anything you like, for example, MyTest. After the name, BotFather will ask for a username of the bot. It must end with “bot”, so users can differentiate it from real people.  You’re done! BotFather will provide authentication token for the bot, just provide it to tbot on initialization with tbot.New().\nGet Updates from Telegram Telegram bots can interact with Telegram servers in two different ways: using long polling or webhooks. In this section we will review both ways and how to implement them in tbot.\nLong polling In long polling setup tbot act as a client, asking to Telegram server for updates and waiting when they're available. Example scenario in following diagram:\n sequenceDiagram tbot-Telegram: Hello Telegram, any updates for me? Telegram--tbot: Yes, here they are! tbot-Telegram: Great! And now? activate Telegram Note right of Telegram: Hm... Wait a min... Telegram--tbot: Found one! deactivate Telegram tbot will use long polling by default, when you create new instance of Bot:\nbot := tbot.New(token) This kind of setup is really handful during development and for moderate load bots. If your bot is suppose to be highly interactive or be used by a lot of users, the best production grade setup is using webhooks.\nWebhooks In the webhooks setup tbot acts like a server, listening for a requests from Telegram with updates.\nIt looks like on the following diagram:\nsequenceDiagram tbot-Telegram: Hi! I'm listening on https://example.com activate Telegram Telegram-tbot: User is typing! Telegram-tbot: User sent you a message! Telegram-tbot: User sent you a picture! Telegram-tbot: User pressed the button! deactivate Telegram To setup webhook just pass it's configuration on initializing:\nbot := tbot.New(token, tbot.WithWebhook(\u0026#34;https://example.com\u0026#34;, \u0026#34;:8080\u0026#34;)) tbot.WithWebhook function takes two parms:\n public URL of web service address for server to listen on  Note: you need HTTPS endpoint with a valid certificate. You may want to use service like LetsEncrypt to get one.  Use Telegram Bots API Client To send messages, files, buttons, actions to the User we use API client. You can get preconfigured client from bot using Client() method:\nbot := tbot.New(token) client := bot.Client() This client provides wrappers for all API methods available on Telegram Bots API platform like SendMessage, SendAction, etc.\nclient.SendMessage(chatID, \u0026#34;hello from tbot!\u0026#34;) Handling Updates To handle updates from Telegram tbot use concept of Handlers. Each Handler type corresponds to different event type happening in Telegram, so we can handle it properly. The most popular things that we want to handle are Messages, Callbacks from buttons, Poll updates.\nTo set handler to bot there are several methods:\nbot.HandleMessage(pattern string, handler func(*tbot.Message)) Set handler for messages. Messages may include not only text, but all different kinds of data: Videos, Images, Documents, etc. First parameter is a regular expression to filter only relevant messages, by default its .*.\nbot.HandleChannelPost(handler func(*tbot.Message)) Similar to previous one, but for handling messages in channels.\nbot.HandleCallback(handler func(*tbot.CallbackQuery)) Handle callback queries from Inline buttons.\nbot.HandlePollUpdate(handler func(*tbot.Poll)) Handle polls updates, just gets updated poll state.\nFull list of supported Handlers you can find in reference.\n"});index.add({'id':1,'href':'/tbot-doc/examples/','title':"Examples",'content':"Examples Basic package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/yanzay/tbot/v2\u0026#34; ) func main() { bot := tbot.New(os.Getenv(\u0026#34;TELEGRAM_TOKEN\u0026#34;)) c := bot.Client() bot.HandleMessage(\u0026#34;.*yo.*\u0026#34;, func(m *tbot.Message) { c.SendMessage(m.Chat.ID, \u0026#34;hello!\u0026#34;) }) err := bot.Start() if err != nil { log.Fatal(err) } } Webhook package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/yanzay/tbot/v2\u0026#34; ) func main() { bot := tbot.New(os.Getenv(\u0026#34;TELEGRAM_TOKEN\u0026#34;), tbot.WithWebhook(\u0026#34;https://test.com\u0026#34;, \u0026#34;:8080\u0026#34;)) c := bot.Client() bot.HandleMessage(\u0026#34;ping\u0026#34;, func(m *tbot.Message) { c.SendMessage(m.Chat.ID, \u0026#34;pong\u0026#34;) }) log.Fatal(bot.Start()) } Cowsay package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;unicode/utf8\u0026#34; \u0026#34;github.com/yanzay/tbot/v2\u0026#34; ) func main() { token := os.Getenv(\u0026#34;TELEGRAM_TOKEN\u0026#34;) bot := tbot.New(token) c := bot.Client() bot.HandleMessage(\u0026#34;cowsay .+\u0026#34;, func(m *tbot.Message) { text := strings.TrimPrefix(m.Text, \u0026#34;cowsay \u0026#34;) cow := fmt.Sprintf(\u0026#34;```\\n%s\\n```\u0026#34;, cowsay(text)) c.SendMessage(m.Chat.ID, cow, tbot.OptParseModeMarkdown) }) bot.Start() } func cowsay(text string) string { lineLen := utf8.RuneCountInString(text) + 2 topLine := fmt.Sprintf(\u0026#34; %s \u0026#34;, strings.Repeat(\u0026#34;_\u0026#34;, lineLen)) textLine := fmt.Sprintf(\u0026#34;\u0026lt; %s \u0026gt;\u0026#34;, text) bottomLine := fmt.Sprintf(\u0026#34; %s \u0026#34;, strings.Repeat(\u0026#34;-\u0026#34;, lineLen)) cow := `\\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || ` resp := fmt.Sprintf(\u0026#34;%s\\n%s\\n%s%s\u0026#34;, topLine, textLine, bottomLine, cow) return resp } Middlewares package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/yanzay/tbot/v2\u0026#34; ) func stat(h tbot.UpdateHandler) tbot.UpdateHandler { return func(u *tbot.Update) { start := time.Now() h(u) log.Printf(\u0026#34;Handle time: %v\u0026#34;, time.Now().Sub(start)) } } func main() { bot := tbot.New(os.Getenv(\u0026#34;TELEGRAM_TOKEN\u0026#34;)) c := bot.Client() bot.Use(stat) // add stat middleware to bot \tbot.HandleMessage(\u0026#34;\u0026#34;, func(m *tbot.Message) { c.SendMessage(m.Chat.ID, \u0026#34;hello!\u0026#34;) }) err := bot.Start() if err != nil { log.Fatal(err) } } Get File package main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/yanzay/tbot/v2\u0026#34; ) func main() { token := os.Getenv(\u0026#34;TELEGRAM_TOKEN\u0026#34;) bot := tbot.New(token) client := bot.Client() bot.HandleMessage(\u0026#34;\u0026#34;, func(m *tbot.Message) { // here we check if message contains Document \t// you could also check for other types of files: \t// Audio, Photo, Video, etc. \tif m.Document != nil { doc, err := client.GetFile(m.Document.FileID) if err != nil { log.Println(err) return } url := client.FileURL(doc) resp, err := http.Get(url) if err != nil { log.Println(err) return } defer resp.Body.Close() out, err := os.Create(m.Document.FileName) if err != nil { log.Println(err) return } defer out.Close() io.Copy(out, resp.Body) } }) log.Fatal(bot.Start()) } Send Image package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/yanzay/tbot/v2\u0026#34; ) func main() { bot := tbot.New(os.Getenv(\u0026#34;TELEGRAM_TOKEN\u0026#34;)) c := bot.Client() bot.HandleMessage(\u0026#34;image\u0026#34;, func(m *tbot.Message) { _, err := c.SendPhotoFile(m.Chat.ID, \u0026#34;image.png\u0026#34;, tbot.OptCaption(\u0026#34;this is image\u0026#34;)) if err != nil { fmt.Println(err) } }) err := bot.Start() if err != nil { log.Fatal(err) } } Polls package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/yanzay/tbot/v2\u0026#34; ) var client *tbot.Client func main() { bot := tbot.New(os.Getenv(\u0026#34;TELEGRAM_TOKEN\u0026#34;)) client = bot.Client() // listen poll message and send poll \tbot.HandleMessage(\u0026#34;poll\u0026#34;, sendPoll) // handle poll updates, just print on the screen \tbot.HandlePollUpdate(func(p *tbot.Poll) { fmt.Println(\u0026#34;Poll update received:\u0026#34;) fmt.Println(p.Question) for _, opt := range p.Options { fmt.Println(opt.Text, opt.VoterCount) } }) bot.Start() } func sendPoll(m *tbot.Message) { options := []string{ \u0026#34;Perfect\u0026#34;, \u0026#34;Good\u0026#34;, \u0026#34;So so\u0026#34;, } client.SendPoll(m.Chat.ID, \u0026#34;How are you?\u0026#34;, options) } Inline Buttons package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/yanzay/tbot/v2\u0026#34; ) type application struct { client *tbot.Client votings map[string]*voting } type voting struct { ups int downs int } func main() { token := os.Getenv(\u0026#34;TELEGRAM_TOKEN\u0026#34;) bot := tbot.New(token) app := \u0026amp;application{ votings: make(map[string]*voting), } app.client = bot.Client() bot.HandleMessage(\u0026#34;/vote\u0026#34;, app.votingHandler) bot.HandleCallback(app.callbackHandler) bot.Start() } func (a *application) votingHandler(m *tbot.Message) { buttons := makeButtons(0, 0) msg, _ := a.client.SendMessage(m.Chat.ID, \u0026#34;Please vote\u0026#34;, tbot.OptInlineKeyboardMarkup(buttons)) votingID := fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, m.Chat.ID, msg.MessageID) a.votings[votingID] = \u0026amp;voting{} } func (a *application) callbackHandler(cq *tbot.CallbackQuery) { votingID := fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, cq.Message.Chat.ID, cq.Message.MessageID) v := a.votings[votingID] if cq.Data == \u0026#34;up\u0026#34; { v.ups++ } if cq.Data == \u0026#34;down\u0026#34; { v.downs++ } buttons := makeButtons(v.ups, v.downs) a.client.EditMessageReplyMarkup(cq.Message.Chat.ID, cq.Message.MessageID, tbot.OptInlineKeyboardMarkup(buttons)) a.client.AnswerCallbackQuery(cq.ID, tbot.OptText(\u0026#34;OK\u0026#34;)) } func makeButtons(ups, downs int) *tbot.InlineKeyboardMarkup { button1 := tbot.InlineKeyboardButton{ Text: fmt.Sprintf(\u0026#34;👍 %d\u0026#34;, ups), CallbackData: \u0026#34;up\u0026#34;, } button2 := tbot.InlineKeyboardButton{ Text: fmt.Sprintf(\u0026#34;👎 %d\u0026#34;, downs), CallbackData: \u0026#34;down\u0026#34;, } return \u0026amp;tbot.InlineKeyboardMarkup{ InlineKeyboard: [][]tbot.InlineKeyboardButton{ []tbot.InlineKeyboardButton{button1, button2}, }, } } "});index.add({'id':2,'href':'/tbot-doc/quick-start/','title':"Quick Start",'content':"Quick Start Installation go get github.com/yanzay/tbot/v2 Usage Simple usage example:\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/yanzay/tbot/v2\u0026#34; ) func main() { bot := tbot.New(os.Getenv(\u0026#34;TELEGRAM_TOKEN\u0026#34;)) c := bot.Client() bot.HandleMessage(\u0026#34;.*yo.*\u0026#34;, func(m *tbot.Message) { c.SendChatAction(m.Chat.ID, tbot.ActionTyping) time.Sleep(1 * time.Second) c.SendMessage(m.Chat.ID, \u0026#34;hello!\u0026#34;) }) err := bot.Start() if err != nil { log.Fatal(err) } } "});index.add({'id':3,'href':'/tbot-doc/categories/','title':"Categories",'content':""});index.add({'id':4,'href':'/tbot-doc/docs/','title':"Docs",'content':""});index.add({'id':5,'href':'/tbot-doc/tags/','title':"Tags",'content':""});index.add({'id':6,'href':'/tbot-doc/','title':"tbot documentation",'content':"tbot - Telegram Bot Server   Full Telegram Bot API 4.4 support Zero dependency Type-safe API client with functional options Capture messages by regexp Middlewares support Can be used with go modules Support for external logger MIT licensed  Getting started  Reference  Github    "});})();